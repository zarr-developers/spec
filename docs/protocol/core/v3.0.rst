Zarr core protocol version 3.0
==============================


Conceptual model
----------------

A Zarr *hierarchy* is a tree structure, where each node in the tree is
either a *group* or an *array*. Group nodes may have children
but array nodes may not.

Each node in a hierarchy has a *name* which is a string of ASCII
characters with some additional constraints. Two sibling nodes cannot 
have the same name. The root node does not have a name.

Each node in a hierarchy has a *path* which uniquely identifies that
node and defines its location within the hierarchy. The path is formed 
by joining together the "/" character, followed by the names of all 
ancestor nodes separated by the "/" character, followed by the name of 
the node itself. For example, the path "/foo/bar" identifies a node 
named "bar", whose parent is named "foo", whose parent is the root of 
the hierarchy. The string "/" identifies the root node.

An array has a fixed number of zero or more *dimensions*. Each dimension has an
integer length. The core protocol only considers the case where the
lengths of all dimensions are finite. However, protocol extensions may
be defined which allow a dimension to have infinite or variable
length.

The *shape* of an array is the tuple of dimension lengths. For
example, if an array has 2 dimensions, where the length of the first
dimension is 100 and the length of the second dimension is 20, then
the shape of the array is (100, 20).

An array contains zero or more *elements*. Each element can be
identified by a tuple of coordinates, one for each dimension of the
array. If all dimensions of an array have finite length, then the
number of elements in the array is given by the product of the
dimension lengths. An array element may be empty, or it may have a
value.

An array is associated with a *data type*. A data type defines the set
of possible values that the array may contain, and a binary
representation (i.e., sequence of bytes) for each possible value. For
example, the little-endian 32-bit signed integer data type defines
binary representations for all integers in the range âˆ’2,147,483,648 to
2,147,483,647. The core protocol only considers a limited set of data
types, but protocol extensions may define other data types.

An array is divided into a set of *chunks*, where each chunk is a
hyperrectangle defined by a tuple of intervals, one for each dimension
of the array. The shape of a chunk is the tuple of interval lengths,
and the size of a chunk (i.e., number of elements contained within the
chunk) is the product of its interval lengths.

The chunks of an array are organised into a *grid*. The core protocol
only considers the case where all chunks have the same shape and the
chunks form a regular grid. However, protocol extensions may define
other grid types such as rectilinear grids.

An array is associated with a *memory layout* which defines how to
construct a binary representation of a single chunk by organising the
binary values within the chunk into a single contiguous sequence of
bytes. The core protocol defines two types of memory layout based on
"C" (row-major) and "F" (column-major) ordering of values, but
protocol extensions may define other memory layouts.

An array is associated with an *encoding pipeline*, which is a
sequence of zero or more *codecs* that transforms the binary
representation of a chunk in some way. For example, an encoding
pipeline might include a checksum codec to ensure data integrity, and
a compression codec to reduce data size. All codecs implement a common
*codec interface* which provides a pair of operations, one to perform
the transformation (encode), the other to reverse the transformation
(decode).

Each node in a hierarchy is represented by a *metadata document*,
which is a machine-readable document containing essential processing
information about the node. For example, an array metadata document
will specify the number of dimensions, length of each dimension, data
type, chunk shape, memory layout and encoding pipeline for that array.

Each node in a hierarchy may have an *attributes document*, which is a
machine-readable document containing information that may be useful to
users of the data but is not essential to the basic processing of the
node.

The metadata, attributes and encoded chunk data for all nodes in a
hierarchy are held in a *store*. To enable a variety of different
store types to be used, the core protocol defines a simple *store
interface* which is a common set of operations that a store must
provide.


Node names
----------

TODO define constraints on node names


Data types
----------

TODO define core data types

Regular chunk grids
-------------------

TODO define regular chunk grids, including how to form a key for each chunk in a grid


Memory layouts
--------------

TODO define "C" and "F" memory layouts

Codec interface
---------------

TODO define the codec interface


Array metadata
--------------

TODO define the structure and content of array metadata documents


Group metadata
--------------

TODO define the structure and content of group metadata documents


User attributes
---------------

TODO define attributes documents


Stores
------

A Zarr store is a system that can be used to store and retrieve data
from a Zarr hierarchy. For a store to be compatible with this
protocol, it must support a set of operations defined in the `Store
interface`_ subsection. The store interface can be implemented using a
variety of underlying storage technologies, described in the
subsection on `Store implementations`_.

Store interface
~~~~~~~~~~~~~~~

The store interface is intended to be simple to implement using a
variety of different underlying storage technologies. It is defined in
a general way here, but it should be straightforward to translate into
a software interface in any given programming languages. The goal is
that an implementation of this specification could be modular and
allow for different store implementations to be used.

The store interface defines a set of operations involving `keys` and
`values`. In the context of this interface, a `key` is any ASCII
string containing only characters in the ranges `a-z`, `A-Z`, `0-9`,
or in the set `/.-_`; and a `value` is any sequence of bytes. It is
assumed that the store holds (`key`, `value`) pairs, with only one
such pair for any given `key`. I.e., a store is a mapping from keys to
values.

The following operations are required:

``set_value`` - Store a (`key`, `value`) pair.

    | Parameters: `key`, `value`
    | Output: none

``get_value`` - Retrieve the `value` associated with a given `key`.

    | Parameters: `key`
    | Output: `value`

``list_keys`` - Retrieve all `keys` in the store.

    | Parameters: none
    | Output: set of `keys`

``contains_key`` - Determine if the store contains a given `key`.

    | Parameters: `key`
    | Output: True or False

The following operations are optional, but if provided may be used by
an implementation of this protocol to optimise some operations:

``list_keys_with_prefix`` - Retrieve all keys with a given prefix.

    | Parameters: `key` prefix
    | Output: set of `keys`

    If not supported, this operation can be achieved by using
    `list_keys` then filtering the resulting set of keys to those with
    the given prefix.
    
``list_prefixes`` - Retrieve all key prefixes which themselves have a
given prefix, assuming the delimiter "/".

    | Parameters: `key` prefix
    | Output: set of `key` prefixes

    For example, if a store contains the keys "a/b", "a/c", "d", "e",
    "e/f", then ``list_prefixes("")`` would return "a/" and "e/".

    For example, if a store contains the keys "foo/bar/baz" and
    "foo/spam/eggs" then ``list_prefixes("")`` would return "foo/",
    and ``list_prefixes("foo/")`` would return "foo/bar/" and
    "foo/spam/".

    The ``list_prefixes`` operation, if available, allows keys to be
    queried in a similar manner to how directories on a file system
    can be listed, although note that there is no requirement for a
    store implementation to use a file system or to be aware of any
    structure within the keys or attach any special meaning to the "/"
    character within keys.

    If the ``list_prefixes`` operation is not supported by a store then
    the same operation can be achieved by obtaining the result of the
    ``list_keys`` operation and post-processing the keys by @@TODO
    describe algorithm succintly@@.


Store implementations
~~~~~~~~~~~~~~~~~~~~~

TODO 


Storage protocol
----------------

This section describes how to translate high level operations to
create, delete or modify Zarr hierarchies, groups or arrays, into low
level operations on the key/value store interface defined above.

Key prefixes
~~~~~~~~~~~~

This section makes a distinction between `hierarchy paths`, which are
logical paths which define the location of group or array nodes within
a Zarr hierarchy, and `storage keys`, which are keys used to store and
retrieve metadata and data via the store interface.

The Zarr storage protocol uses a mapping between hierarchy paths and
storage key prefixes, described as follows.

A hierarchy path is translated into a key prefix by removing the
leading "/", then splitting the hierarchy path into path components by
the "/" delimiter. Each path component is then translated into a key
component by appending ".g" if the path component corresponds to a
group or appending ".a" if the path component corresponds to an
array. These key components are then rejoined using the "/"
delimiter. To make it easier for various storage systems to provide
optimisations, separate key prefixes are used for metadata and chunk
data. For metadata the prefix "meta/" is prepended, and for chunk data
the prefix "data/" is prepended. Finally, a trailing "/" is appended
if not already present.

For a group at an arbitrary hierarchy path `P`, let `M` be the
corresponding metadata key prefix. The key for the group metadata
document is formed by appending "group.json" to `M`.

For an array at an arbitrary hierarchy path `P`, let `M` be the
corresponding metadata key prefix and `D` be the corresponding data
prefix. The key for the array metadata document is formed by appending
"array.json" to `M`. @@TODO chunk keys@@.

@@TODO keys for user attributes.@@

For example, for a group at the root hierarchy path "/", the metadata
key prefix is "meta/", and the group metadata document is stored under
the key "meta/group.json". The data key prefix is "data/".

For example, for a group at hierarchy path "/foo/bar", the metadata
key prefix is "meta/foo.g/bar.g/", and the group metadata document is
stored under the key "meta/foo.g/bar.g/group.json". The data key
prefix is "data/foo.g/bar.g/".

For example, for an array at hierarchy path "/spam/eggs", the metadata
key prefix is "meta/spam.g/eggs.a/", and the array metadata document
is stored under the key "meta/spam.g/eggs.a/array.json". The data key
prefix is "data/spam.g/foo.a/" and chunk keys will be formed by
appending the chunk key suffix to this prefix. @@TODO cross-check
language against chunk grid terminology re chunk keys.@@


Protocol operations
~~~~~~~~~~~~~~~~~~~

@@TODO generalise so this section can be normative, plus examples.@@

Let `P` be an arbitrary hierarchy path. Let `meta_key_prefix(P)` be a
function that returns the metadata key prefix for `P`, and let
`data_key_prefix(P)` be a function that returns the data key prefix
for `P`. Let "+" be the string concatenation operator.

**Create a group at hierarchy path `P`.**

    Let `value` be the serialisation of a valid group metadata
    document. Let `key` be ``meta_key_prefix(P) +
    "group.json"``. Invoke ``set_value(key, value)``.

    For example, if `P` is the root hierarchy path "/", invoke
    ``set_value("meta/group.json", value)``.

    For example, if `P` is the hierarchy path "/foo/bar", invoke
    ``set_value("meta/foo.g/bar.g/group.json", value)``.

    When a group is created at path `P` where `P` is not the root
    hierarchy path, then it is **not** necessary to check if groups
    already exist at all ancestor paths of `P`. For example, if `P` is
    "/foo/bar", it is not necessary to check if groups exist at paths
    "/" and "/foo", nor is it necessary to create groups at these
    ancestor paths if they do not exist. Explicitly creating a group
    at a non-root path `P` implicitly creates groups at all ancestor
    paths if they have not been explicitly created.

**Create an array at hierarchy path "/spam/eggs".**

    Let `value` be the serialisation of a valid array metadata
    document. Invoke ``set_value("meta/spam.g/eggs.a/array.json",
    value)``.

**List children of the group at hierarchy root path "/".**

    Let `prefixes` be the result of invoking
    ``list_prefixes("meta/")``. @@TODO finish this.

**List all nodes in a hierarchy.**

    @@TODO better explanation@@. List all keys in the store with
    prefix "meta/". Collect all array nodes by filtering for keys
    ending in "array.json" and reconstructing their hierarchy
    path. Collect all explicit group nodes by filtering for keys
    ending in "group.json" and reconstructing their hierarchy
    paths. Collect all implicit group nodes.

**Delete an array at path "/spam/eggs".**

    @@TODO better explanation@@. Delete all keys with the prefix
    "meta/spam.g/eggs.a/". Delete all keys with the prefix
    "data/spam.g/eggs.a/".

**Delete a group at path "/foo/bar".**

    @@TODO better explanation@@. Delete all keys with the prefix
    "meta/foo.g/bar.g/". Delete all keys with the prefix
    "data/foo.g/bar.g".

**Replace an existing array at path "/spam/eggs" with a new array.**

    @@TODO

**Replace an existing array at path "/spam/eggs" with a new grouop.**

    @@TODO

**Replace an existing group at path "/foo/bar" with a new array.**

    @@TODO
    
**Store element values in an array.**

    @@TODO
    
**Retrieve element values in an array.**

    @@TODO
    
**Reshape an array.**

    @@TODO
    
**Store user attributes in a group or array.**

    @@TODO
    
**Retrieve user attribute in a group or array.**
  
    @@TODO
    
**Determine if an array exists at a given hierarchy path.**

    @@TODO
    
**Determine if a group exists at a given hierarchy path.**

    @@TODO
    
  
