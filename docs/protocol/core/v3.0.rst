Zarr core protocol version 3.0
==============================


Conceptual model
----------------

A Zarr *hierarchy* is a tree structure, where each node in the tree is
either a *group* or an *array*. Group nodes may have children
but array nodes may not.

Each node in a hierarchy has a *name* which is a string of ASCII
characters with some additional constraints. Two sibling nodes cannot 
have the same name. The root node does not have a name.

Each node in a hierarchy has a *path* which uniquely identifies that
node and defines its location within the hierarchy. The path is formed 
by joining together the "/" character, followed by the names of all 
ancestor nodes separated by the "/" character, followed by the name of 
the node itself. For example, the path "/foo/bar" identifies a node 
named "bar", whose parent is named "foo", whose parent is the root of 
the hierarchy. The string "/" identifies the root node.

An array has a fixed number of zero or more *dimensions*. Each dimension has an
integer length. The core protocol only considers the case where the
lengths of all dimensions are finite. However, protocol extensions may
be defined which allow a dimension to have infinite or variable
length.

The *shape* of an array is the tuple of dimension lengths. For
example, if an array has 2 dimensions, where the length of the first
dimension is 100 and the length of the second dimension is 20, then
the shape of the array is (100, 20).

An array contains zero or more *elements*. Each element can be
identified by a tuple of coordinates, one for each dimension of the
array. If all dimensions of an array have finite length, then the
number of elements in the array is given by the product of the
dimension lengths. An array element may be empty, or it may have a
value.

An array is associated with a *data type*. A data type defines the set
of possible values that the array may contain, and a binary
representation (i.e., sequence of bytes) for each possible value. For
example, the little-endian 32-bit signed integer data type defines
binary representations for all integers in the range âˆ’2,147,483,648 to
2,147,483,647. The core protocol only considers a limited set of data
types, but protocol extensions may define other data types.

An array is divided into a set of *chunks*, where each chunk is a
hyperrectangle defined by a tuple of intervals, one for each dimension
of the array. The shape of a chunk is the tuple of interval lengths,
and the size of a chunk (i.e., number of elements contained within the
chunk) is the product of its interval lengths.

The chunks of an array are organised into a *grid*. The core protocol
only considers the case where all chunks have the same shape and the
chunks form a regular grid. However, protocol extensions may define
other grid types such as rectilinear grids.

An array is associated with a *memory layout* which defines how to
construct a binary representation of a single chunk by organising the
binary values within the chunk into a single contiguous sequence of
bytes. The core protocol defines two types of memory layout based on
"C" (row-major) and "F" (column-major) ordering of values, but
protocol extensions may define other memory layouts.

An array is associated with an *encoding pipeline*, which is a
sequence of zero or more *codecs* that transforms the binary
representation of a chunk in some way. For example, an encoding
pipeline might include a checksum codec to ensure data integrity, and
a compression codec to reduce data size. All codecs implement a common
*codec interface* which provides a pair of operations, one to perform
the transformation (encode), the other to reverse the transformation
(decode).

Each node in a hierarchy is represented by a *metadata document*,
which is a machine-readable document containing essential processing
information about the node. For example, an array metadata document
will specify the number of dimensions, length of each dimension, data
type, chunk shape, memory layout and encoding pipeline for that array.

Each node in a hierarchy may have an *attributes document*, which is a
machine-readable document containing information that may be useful to
users of the data but is not essential to the basic processing of the
node.

The metadata, attributes and encoded chunk data for all nodes in a
hierarchy are held in a *store*. To enable a variety of different
store types to be used, the core protocol defines a simple *store
interface* which is a common set of operations that a store must
provide.


Node names
----------

TODO define constraints on node names


Data types
----------

TODO define core data types

Regular chunk grids
-------------------

TODO define regular chunk grids, including how to form a key for each chunk in a grid


Memory layouts
--------------

TODO define "C" and "F" memory layouts

Codec interface
---------------

TODO define the codec interface


Array metadata
--------------

TODO define the structure and content of array metadata documents


Group metadata
--------------

TODO define the structure and content of group metadata documents


User attributes
---------------

TODO define attributes documents


Stores
------

A Zarr store is a system that can be used to store and retrieve data
from a Zarr hierarchy. For a store to be compatible with this
protocol, it must support a set of operations defined in the `Store
interface`_ subsection. The store interface can be implemented using a
variety of underlying storage technologies, described in the
subsection on `Store implementations`_.

Store interface
~~~~~~~~~~~~~~~

The store interface is intended to be simple to implement using a
variety of different underlying storage technologies. It is defined in
a general way here, but it should be straightforward to translate into
a software interface in any given programming languages. The goal is
that an implementation of this specification could be modular and
allow for different store implementations to be used.

The store interface defines a set of operations involving `keys` and
`values`. In the context of this interface, a `key` is any ASCII
string containing only characters in the ranges `a-z`, `A-Z`, `0-9`,
or in the set `/.-_`; and a `value` is any sequence of bytes. It is
assumed that the store holds (`key`, `value`) pairs, with only one
such pair for any given `key`. I.e., a store is a mapping from keys to
values.

The following operations are **required**:

``set`` - Store a (`key`, `value`) pair.

    | Parameters: `key`, `value`
    | Output: none

``get`` - Retrieve the `value` associated with a given `key`.

    | Parameters: `key`
    | Output: `value`

``del`` - Delete the given key/value pair from the store.

    | Parameters: `key`
    | Output: none

``list`` - Retrieve all `keys` in the store.

    | Parameters: none
    | Output: set of `keys`

The following operations are **optional**, but if provided may be used
by an implementation of this protocol to optimise some operations:

``listpre`` - Retrieve all keys with a given prefix.

    | Parameters: `prefix`
    | Output: set of `keys` with the given `prefix`

    For example, if a store contains the keys "a/b" and "a/c", then
    ``listpre("a/")`` would return "a/b" and "a/c".

    If ``listpre`` is not supported, fallback to ``list`` with
    post-processing of the results.

``listdir`` - Retrieve all keys with a given prefix and which do not
contain "/" after the prefix. (Analogous to listing "files" in a
"directory".)

    | Parameters: `prefix`
    | Output: set of `keys`

    For example, if a store contains the keys "a/b", "a/c", "a/d/e",
    then ``listdir("a/")`` would return "a/b" and "a/c".

    If ``listdir`` is not supported, fallback to ``listpre`` with
    post-processing of the results.


Store implementations
~~~~~~~~~~~~~~~~~~~~~

TODO 


Storage protocol
----------------

This section describes how to translate high level operations to
create, delete or modify Zarr hierarchies, groups or arrays, into low
level operations on the key/value store interface defined above.

Storage keys
~~~~~~~~~~~~

This section makes a distinction between `hierarchy paths`, which are
logical paths which define the location of group or array nodes within
a Zarr hierarchy, and `storage keys`, which are keys used to store and
retrieve metadata and data via the store interface. There is a further
distinction between `metadata keys`, which are storage keys used to
store metadata documents, and `data keys`, which are storage keys used
to store encoded chunks.

The Zarr storage protocol uses a mapping between hierarchy paths and
storage keys, described as follows.

For a group at an arbitrary non-root hierarchy path `P`, the metadata
key for the group metadata document is formed by concatenating
"meta", `P`, and "/group.json".

For example, for a group at hierarchy path "/foo/bar", the
corresponding metadata key is "meta/foo/bar/group.json".

For an array at an arbitrary hierarchy path `P`, the metadata key for
the array metadata document is formed by concatenating "meta", `P`,
and "/array.json". The data key for array chunks is formed by
concatenating "data", `P`, "/", and the chunk key suffix.

For example, for an array at hierarchy path "/foo/baz", the
corresponding metadata key is "meta/foo/baz/array.json". If the array
has two dimensions, the data key for the chunk with grid coordinates
(0, 0) is "data/foo/baz/0.0".

If the root node is a group, the metadata key is "meta/group.json". If
the root node is an array, the metadata key is "meta/array.json".


Protocol operations
~~~~~~~~~~~~~~~~~~~

Let `P` be an arbitrary hierarchy path.

Let `group_meta_key(P)` be a function that returns the group metadata
key for `P`.

Let `array_meta_key(P)` be a function that returns the array metadata
key for `P`.

Let `data_key(P, i, j, ...)` be a function that returns the data key
for `P` for the chunk with grid coordinates (i, j, ...).

Let "+" be the string concatenation operator.

**Create a group at hierarchy path `P`:**

    Let `value` be the serialisation of a valid group metadata
    document.

    Let `key` be ``group_meta_key(P)``.

    Perform ``set(key, value)``.

**Create an array at hierarchy path `P`:**

    Let `value` be the serialisation of a valid array metadata
    document.

    Let `key` be ``array_meta_key(P)``.

    Perform ``set(key, value)``.

**List children of the group at hierarchy path `P`.**

    @@TODO
    
**List all nodes in a hierarchy.**

    @@TODO

**Delete a node at path `P`.**

    @@TODO

**Store element values in an array.**

    @@TODO
    
**Retrieve element values in an array.**

    @@TODO
    
**Determine if a node exists at a given hierarchy path.**

    @@TODO
    

@@TODO describe implicit groups...@@ When a group is created at path
`P` where `P` is not the root hierarchy path, then it is **not**
necessary to check if groups already exist at all ancestor paths of
`P`. For example, if `P` is "/foo/bar", it is not necessary to check
if groups exist at paths "/" and "/foo", nor is it necessary to create
groups at these ancestor paths if they do not exist. Explicitly
creating a group at a non-root path `P` implicitly creates groups at
all ancestor paths.

